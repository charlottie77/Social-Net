<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive particles</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	</head>

	<body>
		<div id="container">
			 <!--<canvas width="1400" height="1200" ></canvas> -->
		</div>
		<!--<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> webgl - interactive - particles</div>-->


		<script src="js/three.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/d3-force.min.js"></script>
		<script src="js/d3.min.js"></script>
		<script src="js/controls/DragControls.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/controls/TrackballControls.js"></script>

		<!--<script type="x-shader/x-vertex" id="vertexshader">-->
			<!--attribute float size;-->
			<!--attribute vec3 customColor;-->
			<!--varying vec3 vColor;-->
			<!--void main() {-->
				<!--vColor = customColor;-->
				<!--vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );-->
				<!--gl_PointSize = size * ( 300.0 / -mvPosition.z );-->
				<!--gl_Position = projectionMatrix * mvPosition;-->
			<!--}-->
		<!--</script>-->

		<!--<script type="x-shader/x-fragment" id="fragmentshader">-->
			<!--uniform vec3 color;-->
			<!--uniform sampler2D texture;-->
			<!--varying vec3 vColor;-->
			<!--void main() {-->
				<!--gl_FragColor = vec4( color * vColor, 1.0 );-->
				<!--gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );-->
				<!--if ( gl_FragColor.a < ALPHATEST ) discard;-->
			<!--}-->
		<!--</script>-->
		

		<script type="text/javascript">
			//if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
			var container;
			var renderer, scene, camera, stats,controls;
			var group;
			var raycaster, intersects;
			var mouse, INTERSECTED;
			var width = window.innerWidth;
			var height = window.innerHeight;
            //var canvas = document.querySelector("canvas");
            //var context = canvas.getContext("2d");
            var spheres = [];
            var three_links = [];
            var relationgraph = [];

            var targetRotation = 0;
            var targetRotationOnMouseDown = 0;
            var mouseX = 0;
            var mouseXOnMouseDown = 0;
            var windowHalfX = window.innerWidth / 2;
            var windowHalfY = window.innerHeight / 2;
            var helpPlane;
            var offset = new THREE.Vector3();

			init();
			animate();

			function init() {
				container = document.getElementById( 'container' );
				raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();

                camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
                camera.position.set(0, 0, 400);
                camera.lookAt(new THREE.Vector3(0, 0, 0));

                controls = new THREE.OrbitControls( camera );
                controls.target = new  THREE.Vector3(0, 0, 0);
                controls.maxDistance = 300;


//                controls.rotateSpeed = 5.0;
//				controls.zoomSpeed = 3.0;
//                controls.panSpeed = 0.8;
//                controls.noZoom = false;
//                controls.noPan = false;
//                controls.staticMoving = true;
//                controls.dynamicDampingFactor = 0.3;

				scene = new THREE.Scene();
                scene.add(camera);

                renderer = new THREE.WebGLRenderer({antialiasing: true});
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize(width, height);
                renderer.setClearColor( 0xf0f0f0);

				container.appendChild( renderer.domElement );



                group = new THREE.Group();
                group.position.y = 50;
                scene.add( group );

                var simulation = d3.forceSimulation()
                    .force("link", d3.forceLink().id(function(d) { return d.id; }))
                    .force("charge", d3.forceManyBody())
                    .force("center", d3.forceCenter(width / 2, height / 2));

                for (var i = 0; i < 16; i++) {
                    // set up the sphere vars
                    var radius = 5,
                        segments = 16,
                        rings = 16;

                    // create the sphere's material
                    var sphereMaterial = new THREE.MeshLambertMaterial(
                        {
                            color: 0x6bcbc8
                        });

                    var sphere = new THREE.Mesh(
                        new THREE.SphereGeometry(
                            radius,
                            segments,
                            rings),
                        sphereMaterial);

                    spheres.push(sphere);

                    // add the sphere to the scene
                    group.add(sphere);
                }



                d3.json("mesi.json", function(error, graph) {
                    if (error) throw error;
                    simulation
                        .nodes(graph.nodes);
                      //  .on("tick", ticked);

                    simulation.force("link")
                        .links(graph.links);

//                    d3.select(canvas)
//                        .call(d3.drag()
//                            .container(canvas)
//                            .subject(dragsubject)
//                            .on("start", dragstarted)
//                            .on("drag", dragged)
//                            .on("end", dragended));
                    for(let i = 0; i < 16; i++ )
                    {
                        var pointTemp = new THREE.Vector3(graph.nodes[i].x, graph.nodes[i].y, 0);
                        console.log(pointTemp);
                        relationgraph.push(pointTemp);
                    }
                    for(let i = 0; i < 16; i++)
                    {
                        spheres[i].position.set(relationgraph[i].x, relationgraph[i].y, 0);
                    }
                    for(let i = 0; i < graph.links.length; i++)
					{
                        var material = new THREE.LineBasicMaterial({ color: 0x2f5554, linewidth: 1});

                        var geometry = new THREE.Geometry();
                        geometry.vertices.push( new THREE.Vector3( graph.links[i].source.x, graph.links[i].source.y, 0 ) );
                        geometry.vertices.push( new THREE.Vector3( graph.links[i].target.x, graph.links[i].target.y, 0 ) );

                        var line = new THREE.Line( geometry, material );
                        three_links.push(line);
                        group.add(line);
//                        line.userData = {
//                            source: data.links[i].source,
//							target: data.links[i].target };
					}

//                    function ticked() {
////                        context.clearRect(0, 0, width, height);
////
////                        context.beginPath();
////                        graph.links.forEach(drawLink);
////                        context.strokeStyle = "#aaa";
////                        context.stroke();
////
////                        context.beginPath();
////                        graph.nodes.forEach(drawNode);
////                        context.fill();
////                        context.strokeStyle = "#fff";
////                        context.stroke();
//
//
//                       // renderer.render(scene, camera);
//
//                    }
                });

                helpPlane = new THREE.Mesh(new THREE.PlaneBufferGeometry(500, 500, 8, 8), new THREE.MeshBasicMaterial({color: 0xffffff}));
                //helpPlane.visible = false;
                scene.add(helpPlane);

                //var dragControls = new THREE.DragControls( spheres, camera, renderer.domElement );
                //dragControls.addEventListener( 'dragstart', function ( event ) { controls.enabled = false; } );
                //dragControls.addEventListener( 'dragend', function ( event ) { controls.enabled = true; } );
                var pointLight = new THREE.PointLight( 0xFFFFFF );

                // set its position
                pointLight.position.x = 10;
                pointLight.position.y = 50;
                pointLight.position.z = 130;

                var pointLight1 = new THREE.PointLight( 0xFFFFFF );

                // set its position
                pointLight1.position.x = 10;
                pointLight1.position.y = 50;
                pointLight1.position.z = -130;

                // add to the scene
                scene.add(pointLight);
                scene.add(pointLight1);

                stats = new Stats();
                container.appendChild( stats.dom );
                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                document.addEventListener( 'mousedown', onDocumentMouseDown, false );
                document.addEventListener( 'mouseup', onDocumentMouseUp,false);
                //document.addEventListener( 'touchstart', onDocumentTouchStart, false );
                //document.addEventListener( 'touchmove', onDocumentTouchMove, false );
                document.addEventListener( 'resize', onWindowResize, false );

            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            function onDocumentMouseDown( event ) {
                event.preventDefault();

                //document.addEventListener('mouseup', onDocumentMouseUp, false);
                //document.addEventListener('mouseout', onDocumentMouseOut, false);
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera( mouse, camera );
                var sects = raycaster.intersectObjects(spheres);

                if(sects.length > 0)
				{
				    controls.enabled = false;
				    INTERSECTED = sects[0].object;

				}
                var interp = raycaster.intersectObject(helpPlane);
                console.log(interp[0]);
                offset.copy(interp[0].point).sub(helpPlane.position);


                //mouseXOnMouseDown = event.clientX - windowHalfX;


                //targetRotationOnMouseDown = targetRotation;
            }

            function onDocumentMouseMove( event ) {
                event.preventDefault();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera( mouse, camera );

                intersects = raycaster.intersectObjects( spheres );

                if(INTERSECTED)
				{
                    var interp = raycaster.intersectObject( helpPlane );
				    console.log(interp[0]);
				    INTERSECTED.position.copy(interp[0].point.sub(offset));
				}
				else
				{
                    var sects = raycaster.intersectObjects(spheres);

                    if(sects.length > 0)
                    {
                        helpPlane.position.copy(sects[0].object.position);
                        helpPlane.lookAt(camera.position);

                    }
				}

// hover turn red
//                raycaster.setFromCamera( mouse, camera );
//
//                intersects = raycaster.intersectObjects( spheres );
//                console.log(spheres);
//
//                if (intersects.length > 0) { //如果有捕捉到object
//                    if (INTERSECTED != intersects[0].object) { //如果换了一个object
//                        if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex); // 将上一个改回他原本的颜色
//                        INTERSECTED = intersects[0].object;  //选中第一个
//                        INTERSECTED.currentHex = INTERSECTED.material.color.getHex(); //取到原本的颜色
//                        INTERSECTED.material.color.set( 0xff0000 ); //将选中的改为红色
//                    }
//                }
//                else {
//                    if (INTERSECTED) INTERSECTED.material.color.set(INTERSECTED.currentHex);
//                    INTERSECTED = null;
//                }
//hover turn red end
				//targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;
            }

            function onDocumentMouseUp( event ) {
                //document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
                //document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
                //document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
                controls.enabled = true;
                INTERSECTED = null;
            }
//            function onDocumentMouseOut( event ) {
//                //document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
//                document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
//                document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
//            }
//            function onDocumentTouchStart( event ) {
//                if ( event.touches.length == 1 ) {
//                    event.preventDefault();
//                    mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
//                    targetRotationOnMouseDown = targetRotation;
//                }
//            }
//            function onDocumentTouchMove( event ) {
//                if ( event.touches.length == 1 ) {
//                    event.preventDefault();
//                    mouseX = event.touches[ 0 ].pageX - windowHalfX;
//                    targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;
//                }
//            }


            function animate() {
                requestAnimationFrame( animate );
                render();
                stats.update();
            }
            function render() {


                controls.update();

                renderer.render( scene, camera );
            }
//
		</script>

	</body>

</html>