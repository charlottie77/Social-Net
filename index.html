<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive particles</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	</head>

	<body>
		<div id="container">
			 <!--<canvas width="1400" height="1200" ></canvas> -->
		</div>
		<!--<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> webgl - interactive - particles</div>-->


		<script src="js/three.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/d3-force.min.js"></script>
		<script src="js/d3.min.js"></script>
		<script src="js/controls/DragControls.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/controls/TrackballControls.js"></script>

		<!--<script type="x-shader/x-vertex" id="vertexshader">-->
			<!--attribute float size;-->
			<!--attribute vec3 customColor;-->
			<!--varying vec3 vColor;-->
			<!--void main() {-->
				<!--vColor = customColor;-->
				<!--vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );-->
				<!--gl_PointSize = size * ( 300.0 / -mvPosition.z );-->
				<!--gl_Position = projectionMatrix * mvPosition;-->
			<!--}-->
		<!--</script>-->

		<!--<script type="x-shader/x-fragment" id="fragmentshader">-->
			<!--uniform vec3 color;-->
			<!--uniform sampler2D texture;-->
			<!--varying vec3 vColor;-->
			<!--void main() {-->
				<!--gl_FragColor = vec4( color * vColor, 1.0 );-->
				<!--gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );-->
				<!--if ( gl_FragColor.a < ALPHATEST ) discard;-->
			<!--}-->
		<!--</script>-->
		

		<script type="text/javascript">
			//if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
			var container;
			var renderer, scene, camera, stats,controls;
			var groupSephere, groupLine;
			var linkNum;
			var raycaster, intersects;
			var mouse, INTERSECTED;
			var width = window.innerWidth;
			var height = window.innerHeight;
            //var canvas = document.querySelector("canvas");
            //var context = canvas.getContext("2d");
            var spheres = [];
            var three_links = [];
            var relationgraph = [];

            var targetRotation = 0;
            var targetRotationOnMouseDown = 0;
            var mouseX = 0;
            var mouseXOnMouseDown = 0;
            var windowHalfX = window.innerWidth / 2;
            var windowHalfY = window.innerHeight / 2;
            var helpPlane;
            var offset = new THREE.Vector3();

            const myLineMaterial = new THREE.LineBasicMaterial({ color: 0x2f5554, linewidth: 1});
            const mySphereMaterial = new THREE.MeshLambertMaterial({ color: 0x6bcbc8 });

			init();
			animate();

			function init() {
				container = document.getElementById( 'container' );
				raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();

                camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
                camera.position.set(0, 0, 400);
                camera.lookAt(new THREE.Vector3(0, 0, 0));

                controls = new THREE.OrbitControls( camera );
                controls.target = new  THREE.Vector3(0, 0, 0);
                controls.maxDistance = 300;


//                controls.rotateSpeed = 5.0;
//				  controls.zoomSpeed = 3.0;
//                controls.panSpeed = 0.8;
//                controls.noZoom = false;
//                controls.noPan = false;
//                controls.staticMoving = true;
//                controls.dynamicDampingFactor = 0.3;

				scene = new THREE.Scene();
                scene.add(camera);

                renderer = new THREE.WebGLRenderer({antialiasing: true});
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize(width, height);
                renderer.setClearColor( 0xf0f0f0);

				container.appendChild( renderer.domElement );



                groupSephere = new THREE.Group();
                groupSephere.position.y = 50;
                scene.add( groupSephere );

                groupLine = new THREE.Group();
                groupLine.position.y = 50;
                scene.add( groupLine );

                var axisHelper = new THREE.AxisHelper( 500 );
                scene.add( axisHelper );

                var simulation = d3.forceSimulation()
                    .force("link", d3.forceLink().id(function(d) { return d.id; }))
                    .force("charge", d3.forceManyBody())
                    .force("center", d3.forceCenter(width / 2, height / 2));

                for (var i = 0; i < 16; i++) {
                    // set up the sphere vars
                    var radius = 5,
                        segments = 16,
                        rings = 16;

                    // create the sphere's material
                    // @注：全局声明常量材质
                    // var sphereMaterial = new THREE.MeshLambertMaterial(
                    //     {
                    //         color: 0x6bcbc8
                    //     });

                    var sphere = new THREE.Mesh(
                        new THREE.SphereGeometry(
                            radius,
                            segments,
                            rings),
                        mySphereMaterial);

                    spheres.push(sphere);

                    // add the sphere to the scene
                    groupSephere.add(sphere);
                }



                d3.json("mesi.json", function(error, graph) {
                    window.GRAPH=graph;
                    if (error) throw error;
                    simulation
                        .nodes(graph.nodes);
                      //  .on("tick", ticked);

                    simulation.force("link")
                        .links(graph.links);
                    console.log(graph.nodes[1].id);
//                    d3.select(canvas)
//                        .call(d3.drag()
//                            .container(canvas)
//                            .subject(dragsubject)
//                            .on("start", dragstarted)
//                            .on("drag", dragged)
//                            .on("end", dragended));
					linkNum = graph.links.length;
                    for(let i = 0; i < 16; i++ )
                    {
                        var pointTemp = new THREE.Vector3(graph.nodes[i].x, graph.nodes[i].y, 0);
                        relationgraph.push(pointTemp);
                    }
                    for(let i = 0; i < 16; i++)
                    {
                        spheres[i].position.set(relationgraph[i].x, relationgraph[i].y, 0);
                        // @注1：把没个sphere的name属性赋值为node的id（json数据里Geborand，Myriel之类的人名），之后就可以通过groupSephere.getObjectByName(那个人名)取到对应的球
                        // @注2：userData属性是用来给你放自定义数据的，在这里放一个叫arrLinkLines的数组存每个球各自连着的线的uuid，这个uuid是什么下面有讲
                        spheres[i].name = graph.nodes[i].id;
                        spheres[i].userData = {arrLinkLines:[]};
                    }
                    for(let i = 0; i < graph.links.length; i++)
					{
                        // @注：通用材质不要每次都new，性能开销大，在声明全局变量myLineMaterial一直用，就像C++ define常量
                        // var material = new THREE.LineBasicMaterial({ color: 0x2f5554, linewidth: 1});

                        var geometry = new THREE.Geometry();
                        geometry.vertices.push( new THREE.Vector3( graph.links[i].source.x, graph.links[i].source.y, 0 ) );
                        geometry.vertices.push( new THREE.Vector3( graph.links[i].target.x, graph.links[i].target.y, 0 ) );

                        var line = new THREE.Line( geometry, myLineMaterial );
                        // console.log(line.uuid);
                        // @注1：在new了一个Line之后就可以取它的uuid属性作为唯一标识符，之后通过groupLine.getObjectByProperty('uuid',那个uuid字符串)来获取line对象
                        // @注2：通过控制台输出GRAPH变量可以看到通过d3.json读取json文件生成的对象的结构，按该结构取到每个links对象的source球的名字和target球的名字，并通过groupSephere.getObjectByName方法取到该球，然后向该球userData属性中的arrLinkLines数组push那条link线的uuid。之后就可以知道动了球之后要重画哪些线了
                        groupSephere
                            .getObjectByName(graph.links[i].source.id)
                            .userData.arrLinkLines.push(line.uuid);
                        groupSephere
                            .getObjectByName(graph.links[i].target.id)
                            .userData.arrLinkLines.push(line.uuid);

                        // @注：同时线要记录下它连接的球的名字，之后靠这个知道要修改哪几个球的arrLinkLines
                        line.userData={
                            target:graph.links[i].target.id,
                            source:graph.links[i].source.id
                        }

                        three_links.push(line);
                        groupLine.add(line);
//                        line.userData = {
//                            source: data.links[i].source,
//							target: data.links[i].target };
					}

//                    function ticked() {
////                        context.clearRect(0, 0, width, height);
////
////                        context.beginPath();
////                        graph.links.forEach(drawLink);
////                        context.strokeStyle = "#aaa";
////                        context.stroke();
////
////                        context.beginPath();
////                        graph.nodes.forEach(drawNode);
////                        context.fill();
////                        context.strokeStyle = "#fff";
////                        context.stroke();
//
//
//                       // renderer.render(scene, camera);
//
//                    }
                });
                var material1 = new THREE.MeshStandardMaterial( {
                    opacity: 0,
                    transparent: true
                } );
                helpPlane = new THREE.Mesh(new THREE.PlaneBufferGeometry(500, 500, 8, 8), material1);
                //helpPlane.visible = false;
                scene.add(helpPlane);

                //var dragControls = new THREE.DragControls( spheres, camera, renderer.domElement );
                //dragControls.addEventListener( 'dragstart', function ( event ) { controls.enabled = false; } );
                //dragControls.addEventListener( 'dragend', function ( event ) { controls.enabled = true; } );
                var pointLight = new THREE.PointLight( 0xFFFFFF );

                // set its position
                pointLight.position.x = 10;
                pointLight.position.y = 50;
                pointLight.position.z = 130;

                var pointLight1 = new THREE.PointLight( 0xFFFFFF );

                // set its position
                pointLight1.position.x = 10;
                pointLight1.position.y = 50;
                pointLight1.position.z = -130;

                // add to the scene
                scene.add(pointLight);
                scene.add(pointLight1);

                stats = new Stats();
                container.appendChild( stats.dom );
                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                document.addEventListener( 'mousedown', onDocumentMouseDown, false );
                document.addEventListener( 'mouseup', onDocumentMouseUp,false);
                //document.addEventListener( 'touchstart', onDocumentTouchStart, false );
                //document.addEventListener( 'touchmove', onDocumentTouchMove, false );
                document.addEventListener( 'resize', onWindowResize, false );

            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            function onDocumentMouseDown( event ) {
                event.preventDefault();

                //document.addEventListener('mouseup', onDocumentMouseUp, false);
                //document.addEventListener('mouseout', onDocumentMouseOut, false);
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera( mouse, camera );
                var sects = raycaster.intersectObjects(spheres);

                if(sects.length > 0)
				{
				    controls.enabled = false;
				    INTERSECTED = sects[0].object;

				}
                var interp = raycaster.intersectObject(helpPlane);
                // console.log(interp[0]);
                offset.copy(interp[0].point).sub(helpPlane.position);


                //mouseXOnMouseDown = event.clientX - windowHalfX;


                //targetRotationOnMouseDown = targetRotation;
            }

            function onDocumentMouseMove( event ) {
                event.preventDefault();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera( mouse, camera );

                intersects = raycaster.intersectObjects( spheres );

                if(INTERSECTED)
				{
                    var interp = raycaster.intersectObject( helpPlane );
				    //console.log(interp[0]);
				    INTERSECTED.position.copy(interp[0].point.sub(offset));

                    // @注：forEach遍历比较方便，而且forEach是回调式不会阻塞，for循环会阻塞主线程
                    INTERSECTED.userData.arrLinkLines.forEach(function(uuid){
                        //console.log(uuid);// @注：回调函数的参数就是遍历的每一个对象，这里就是点击的球的每一个连接线uuid
                        let line = groupLine.getObjectByProperty('uuid',uuid);// @注：拿到该线对象
                        let sourceName = line.userData.source; // @注：提前取出source和target名称数据，等会儿删了就没法取了
                        let targetName = line.userData.target;
                        let index = groupLine.children.indexOf(line);// @注：拿到该线在groupLine.children数组中的位置，方便删除
                        if(index !== -1){// @注：执行了一次删除后这个index在下一次move事件响应的时候有可能还没有生成新的线所以会找不到，返回-1。找不到的时候就不应该再删线了。
                            let sourceNode = groupSephere.getObjectByName(sourceName);
                            let targetNode = groupSephere.getObjectByName(targetName);
                            let sourcePosition = sourceNode.position;
                            let targetPosition = targetNode.position;
                            
                            let geometry = new THREE.Geometry();
                            geometry.vertices.push(sourcePosition);
                            geometry.vertices.push(targetPosition);

                            let line = new THREE.Line(geometry,myLineMaterial);

                            let indexInSource = sourceNode.userData.arrLinkLines.indexOf(uuid);
                            let indexInTarget = targetNode.userData.arrLinkLines.indexOf(uuid);

                            if(indexInSource === -1 || indexInTarget === -1){
                                console.error('异步过程异常，暂停');
                                debugger;
                            }else{
                                sourceNode.userData.arrLinkLines.splice(indexInSource,1);
                                sourceNode.userData.arrLinkLines.push(line.uuid);

                                targetNode.userData.arrLinkLines.splice(indexInTarget,1);
                                targetNode.userData.arrLinkLines.push(line.uuid);
                            }

                            // @注：同时线要记录下它连接的球的名字，之后靠这个知道要修改哪几个球的arrLinkLines
                            line.userData={
                                target:targetName,
                                source:sourceName
                            }

                            groupLine.children.splice(index,1);// @注：删线；感觉可能有更优雅的删线方法
                            groupLine.add(line);// @注：加线，删线加线连在一起操作是为了减少两者之间的时间，间隔越短越不容易观察到线的短暂消失
                        }
                        
                    });

// 				    scene.remove(groupLine);

//                     for(let i = 0; i < linkNum; i++)
//                     {
//                         var material = new THREE.LineBasicMaterial({ color: 0x2f5554, linewidth: 1});

//                         var geometry = new THREE.Geometry();
//                         geometry.vertices.push( new THREE.Vector3( spheres[GRAPH.links[i].source.index].position.x, spheres[GRAPH.links[i].source.index].position.y, 0 ) );
//                         geometry.vertices.push( new THREE.Vector3( spheres[GRAPH.links[i].target.index].position.x, spheres[GRAPH.links[i].target.index].position.y, 0 ) );

//                         var line = new THREE.Line( geometry, material );
//                         three_links.push(line);
//                         groupLine[i] = line;
//                         scene.add(groupLine);
// //                        line.userData = {
// //                            source: data.links[i].source,
// //							target: data.links[i].target };
//                     }

				}
				else
				{
                    var sects = raycaster.intersectObjects(spheres);

                    if(sects.length > 0)
                    {
                        helpPlane.position.copy(sects[0].object.position);
                        helpPlane.lookAt(camera.position);

                    }
				}

// hover turn red
//                raycaster.setFromCamera( mouse, camera );
//
//                intersects = raycaster.intersectObjects( spheres );
//                console.log(spheres);
//
//                if (intersects.length > 0) { //如果有捕捉到object
//                    if (INTERSECTED != intersects[0].object) { //如果换了一个object
//                        if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex); // 将上一个改回他原本的颜色
//                        INTERSECTED = intersects[0].object;  //选中第一个
//                        INTERSECTED.currentHex = INTERSECTED.material.color.getHex(); //取到原本的颜色
//                        INTERSECTED.material.color.set( 0xff0000 ); //将选中的改为红色
//                    }
//                }
//                else {
//                    if (INTERSECTED) INTERSECTED.material.color.set(INTERSECTED.currentHex);
//                    INTERSECTED = null;
//                }
//hover turn red end
				//targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;
            }

            function onDocumentMouseUp( event ) {
                //document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
                //document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
                //document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
                controls.enabled = true;
                INTERSECTED = null;
            }
//            function onDocumentMouseOut( event ) {
//                //document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
//                document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
//                document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
//            }
//            function onDocumentTouchStart( event ) {
//                if ( event.touches.length == 1 ) {
//                    event.preventDefault();
//                    mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
//                    targetRotationOnMouseDown = targetRotation;
//                }
//            }
//            function onDocumentTouchMove( event ) {
//                if ( event.touches.length == 1 ) {
//                    event.preventDefault();
//                    mouseX = event.touches[ 0 ].pageX - windowHalfX;
//                    targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;
//                }
//            }


            function animate() {
                requestAnimationFrame( animate );
                render();
                stats.update();
            }
            function render() {


                controls.update();

                renderer.render( scene, camera );
            }
//
		</script>

	</body>

</html>
